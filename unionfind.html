<!DOCTYPE html>
<html lang="en">
<head>
    <style>
    ul.square {
        list-style-type: square;
      }
      .accordion {
  background-color: #eee;
  color: #444;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-n: 15px;
  transition: 0.4s;
}

.active, .accordion:hover {
  background-color: #ccc; 
}

.panel {
  padding: 0 18px;
  display: none;
  background-color: white;
  overflow: hidden;
}
    </style>
  <title>Union Find</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
</head>
<body>

<nav class="navbar navbar-inverse">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="index.html">Computer Science</a>
    </div>
    <ul class="nav navbar-nav">
      <li><a href="#">Welcome</a></li>
      <li class="dropdown" class="active"><a class="dropdown-toggle" data-toggle="dropdown" href="#">Algorithm <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="active"><a href="unionfind.html">Union Find</a></li>
          <li><a href="#">DFS/BFS</a></li>
          <li><a href="#">Dynamic Programming</a></li>
        </ul>
      </li>
      <li><a href="#">About Me</a></li>
    </ul>
  </div>
</nav>

<div class="container">
    <h3>Union Find</h3>
    <p>What you will learn in this section:</p>
    <ul class="square">
        <li>The idea of <mark>Union Find</mark></li>
        <li>How do we implement it?</li>
      </ul>
      <h3>Union Find</h3>
      <p>Union Find is the approach of constructing graphs. The word union implies already what the algorithm does; creating a union, finding a union between vertices. 
        The only data structure you need is a simple array. Now to the one million dollar question....What do we need it for? 
        It is a basic approach for quickly finding out how many disconnected graphs we have. It's basically being used for a disjoint set of vertices. 
        When I started studying computer science, I always thought, I would not really need union find. The more I got into this topic, I have realized how simple it is.
        You can fastly determine wether your whole graphe is connected, if it has cycles without implementing all kinds of data structures. It is pretty easy using DFS/BFS with
        importing libraries but implementing it all by yourself is a lot of work, while you can do it in 5 minutes with union find and an array. <br>
        As usual, there are a couple of implementations with different runtimes. We are going to learn quick find, quick union, path compression and union rankings.
      </p>
      <br>
      <h3>Implementations<sub><font size="1">Turn your phone horizontically</font></sub></h3>

      <div class="col-sm-5">
      <button class="accordion">Quick Find</button>
      <div class="panel">
        <pre><code>
class UnionFind {
int[] root;
    
  public UnionFind(int n) { //n == #vertices
      root = new int[n];
      for (int i = 0; i < n; i++) {
             root[i] = i;
      }
  }
        
  public void union(int x, int y) {
      int rootOfX = find(x);
      int rootOfY = find(y);
      if (rootOfX != rootOfY) {
          for (int i = 0; i < root.length; i++) {
              if (root[i] == rootOfY) {
                  root[i] = rootOfX;
              }
          }
      }
  }

  public int find(int x) {
    return root[x];
  }

  public boolean isConnected(int x, int y) {
      return find(x) == find(y);
  }
}
            </code></pre>
        </div>

        <button class="accordion">Quick Union</button>
        <div class="panel">
                      <pre><code>
class UnionFind {
int[] root;

  public UnionFind(int n) {
      root = new int[n];
      for (int i = 0; i < n; i++) {
             root[i] = i;
      }
  }
        
  public void union(int x, int y) {
      int rootOfX = find(x);
      int rootOfY = find(y);
      if (rootOfX != rootOfY) {
          for (int i = 0; i < root.length; i++) {
              if (root[i] == rootOfY) {
                  root[i] = rootOfX;
              }
          }
      }
  }

  public int find(int x) {
    return root[x];
  }

  public boolean isConnected(int x, int y) {
      return find(x) == find(y);
  }
}
              </code></pre>
          </div>

          <button class="accordion">Path Compression with ranking</button>
          <div class="panel">
                        <pre><code>
class UnionFind {
int[] root;

  public UnionFind(int n) {
      root = new int[n];
      for (int i = 0; i < n; i++) {
          root[i] = i;
      }
  }
      
  public void union(int x, int y) {
      int rootOfX = find(x);
      int rootOfY = find(y);
      if (rootOfX != rootOfY) {
          for (int i = 0; i < root.length; i++) {
              if (root[i] == rootOfY) {
                  root[i] = rootOfX;
              }
          }
      }
  }

  public int find(int x) {
    return root[x];
  }

  public boolean isConnected(int x, int y) {
      return find(x) == find(y);
  }
}
                </code></pre>
                </div>
            </div>
</div>
  

<script>
    var acc = document.getElementsByClassName("accordion");
    var i;
    
    for (i = 0; i < acc.length; i++) {
      acc[i].addEventListener("click", function() {
        this.classList.toggle("active");
        var panel = this.nextElementSibling;
        if (panel.style.display === "block") {
          panel.style.display = "none";
        } else {
          panel.style.display = "block";
        }
      });
    }
    </script>

  </body>
  </html>
  