<!DOCTYPE html>
<html lang="en">
<head>
    <style>
    ul.square {
        list-style-type: square;
      }
      .accordion {
  background-color: #eee;
  color: #444;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-size: 15px;
  transition: 0.4s;
}

.active, .accordion:hover {
  background-color: #ccc; 
}

.panel {
  padding: 0 18px;
  display: none;
  background-color: white;
  overflow: hidden;
}
    </style>
  <title>Union Find</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
</head>
<body>

<nav class="navbar navbar-inverse">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="index.html">Computer Science</a>
    </div>
    <ul class="nav navbar-nav">
      <li><a href="index.html">Welcome</a></li>
      <li class="dropdown" class="active"><a class="dropdown-toggle" data-toggle="dropdown" href="#">Algorithm <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="active"><a href="unionfind.html">Union Find</a></li>
          <li><a href="#">DFS/BFS</a></li>
          <div class="dropdown-divider"></div>
          <li><a href="#">Dynamic Programming</a></li>
        </ul>
      </li>
      <li><a href="aboutme.html">About Me</a></li>
    </ul>
  </div>
</nav>

<div class="container">
    <h3>Union Find</h3>
    <p>What you will learn in this section:</p>
    <ul class="square">
        <li>The idea of <mark>Union Find</mark></li>
        <li>How do we implement it?</li>
      </ul>
      <h3>Union Find</h3>
      <p>Union Find is the approach of constructing graphs. The word union implies already what the algorithm does; creating a union, finding a union between vertices. 
        The only data structure you need is a simple array. Now to the one million dollar question....What do we need it for? 
        It is a basic approach for quickly finding out how many connected components the whole graph has. It's basically being used for a disjoint set of vertices. 
        When I started studying computer science, I always thought, I would not really need union find. The more I got into this topic, I have realized how simple it is.
        You can fastly determine wether your whole graphe is connected, if it has cycles without implementing all kinds of data structures. It is pretty easy using DFS/BFS with
        importing libraries but implementing it all by yourself is a lot of work, while you can do it in 5 minutes with union find and an array. <br>
        As usual, there are a couple of implementations with different runtimes. We are going to learn quick find, quick union, path compression and union rankings.
      </p>
      <br>
      Your first step would always be to create an array with the size of the amount of vertices. We call this array <mark>root</mark>, because this particular vertex in the index
      of your array is connected to another vertex, or in the beginning, with itself. That is why we initialise every index with the vertex number itself. Second step would be to
      read the edges {u, v} and to do a union(u, v). We compare the actual root numbers of each vertex in the union method and make one of them the root of for both. Imagine we have
      two vertices x and y and an undirected edge which connects both vertices. The root for x is x and y is the root of y. If we union these vertices, one of them needs to be the main root.
      In this algorithm we consider x to be the new root. x still stays the root of itself. Of course all of this might be different, based on how you implement it. 
      Below you can find a couple of implementations.
      <br>
      <h3>Implementations<sub><font size="1">Turn your phone horizontically</font></sub></h3>

      <div class="col-sm-5">
      <button class="accordion">Quick Find</button>
      <div class="panel">
        <pre><code>
class UnionFind {
int[] root;
    
  public UnionFind(int n) { //n == #vertices
      root = new int[n];
      for (int i = 0; i < n; i++) {
             root[i] = i;
      }
  }
        
  public void union(int x, int y) {
      int rootOfX = find(x);
      int rootOfY = find(y);
      if (rootOfX != rootOfY) {
          for (int i = 0; i < root.length; i++) {
              if (root[i] == rootOfY) {
                  root[i] = rootOfX;
              }
          }
      }
  }

  public int find(int x) {
    return root[x];
  }

  public boolean isConnected(int x, int y) {
      return find(x) == find(y);
  }
}
            </code></pre>
        </div>

        <button class="accordion">Quick Union</button>
        <div class="panel">
                      <pre><code>
class UnionFind {
int[] root;

  public UnionFind(int n) {
      root = new int[n];
      for (int i = 0; i < n; i++) {
             root[i] = i;
      }
  }
        
  public void union(int x, int y) {
      int rootOfX = find(x);
      int rootOfY = find(y);
      if (rootOfX != rootOfY) {
          root[rootofY] = rootOfX;
      }
  }

  public int find(int x) {
    while (x != root[x]) {
        x = root[x];
    }
    return x;
  }

  public boolean isConnected(int x, int y) {
      return find(x) == find(y);
  }
}
              </code></pre>
          </div>

          <button class="accordion">Path Compression with ranking</button>
          <div class="panel">
                        <pre><code>
class UnionFind {
int[] root;
int[] rank;
  public UnionFind(int n) {
      root = new int[n];
      rank = new int[n];
      for (int i = 0; i < n; i++) {
          root[i] = i;
          rank[i] = 1;
      }
  }
      
  public void union(int x, int y) {
      int rootOfX = find(x);
      int rootOfY = find(y);
      if (rootOfX != rootOfY) {
          if(rank[rootOfX] > rank[rootOfY]){
              root[rootOfY] = rootOfX;
          } else if(rank[rootOfX] < rank[rootOfY]){
              root[rootOfX] = rootOfY;
          } else {
              root[rootOfY] = rootOfX;
              rank[rootOfX]++;
          }
      }
  }

  public int find(int x) {
      if(x == root[x]){
          return x;
      }
    return root[x] = find(root[x]);
  }

  public boolean isConnected(int x, int y) {
      return find(x) == find(y);
  }
}
                </code></pre>
                </div>
            </div>
</div>
  

<script>
    var acc = document.getElementsByClassName("accordion");
    var i;
    
    for (i = 0; i < acc.length; i++) {
      acc[i].addEventListener("click", function() {
        this.classList.toggle("active");
        var panel = this.nextElementSibling;
        if (panel.style.display === "block") {
          panel.style.display = "none";
        } else {
          panel.style.display = "block";
        }
      });
    }
    </script>

  </body>
  </html>
  